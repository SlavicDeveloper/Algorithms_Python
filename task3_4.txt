В результате нескольких проверок при помощи timeit наиболее эффективным оказался алгоритм reverse_3.

Это происходит потому, что именно в третьем случае мы абстрагировались от циклов.
Циклы в Python довольно медленные, так как в Python все есть объект

То есть, например, используюя цикл while при каждой итерации мы распаковываем объекты столько раз, пока
не будет удовлетворено условие выхода из цикла (reverse_2)

Цикл if/else же из reverse_1 каждый раз проверяет вводимое число на соответствие заданному условию, что
замедляет процесс выполнения функции

Функция reverse_3 не работает с циклами. Здесь используются методы работы со строками. Переменной enter_num
присваевается строчный формат введенного числа enter_num(аргумент функции revers_num_3). Далее переменной revers_num
присваивается значение enter_num, но уже выведенное в обратном порядке при помощи [::-1]

Именно засчет абстрагирования от циклов revers_3 является самым быстрым и оптимальным.

Также была выполнена проверка через cProfile run, однако в данном случае почти невозможно определить
какая из функций реализуется быстрее


